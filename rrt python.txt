https://github.com/nimRobotics/RRT/blob/master/rrt.py

import cv2
import numpy as np
import math
import random
import argparse
import os

#노드 클래스
class Nodes:
    """Class to store the RRT graph"""
    def __init__(self, x,y):
        self.x = x
        self.y = y
        self.parent_x = [] #부모노드 x좌표는 리스트 타입
        self.parent_y = [] #부모노드 y좌표는 리스트 타입


# check collision
def collision(x1,y1,x2,y2): 각 좌표는 충돌을 확인할 두 노드에 대한 좌표
    color=[]
    x = list(np.arange(x1,x2,(x2-x1)/100)) #x범위에 대해서 100개로 세분화
    y = list(((y2-y1)/(x2-x1))*(x-x1) + y1) #100개의 x좌표에 대한 직선의 방정식 결과값 y
    print("collision",x,y)
    for i in range(len(x)): #100개의 x좌표에 대해서
        print(int(x[i]),int(y[i])) #(x, y)좌표 출력
        color.append(img[int(y[i]),int(x[i])]) #(x, y)좌표에 대응하는 이미지 픽셀을 color리스트에 추가. 이미지 픽셀에 접근해야 하기 때문에 정수형으로 변환
    if (0 in color): #color에 0값이 있다면 
        return True #collision
    else: #0값이 없으면
        return False #no-collision

# 장애물에 대한 충돌 확인 및 가공
def check_collision(x1,y1,x2,y2):
    _,theta = dist_and_angle(x2,y2,x1,y1) #두 노드 사이의 각도
    x=x2 + stepSize*np.cos(theta) #x2에 step 사이즈의 cos값을 더함
    y=y2 + stepSize*np.sin(theta) #y2에 step 사이즈의 sin값을 더함
    print(x2,y2,x1,y1)
    print("theta",theta)
    print("check_collision",x,y)

    # TODO: trim the branch if its going out of image area
    # 이미지 영역을 넘어서면 가공
    # print("Image shape",img.shape) 
    hy,hx=img.shape #이미지 크기를 hy와 hx에 저장
    if y<0 or y>hy or x<0 or x>hx: #x와 y에 대해 범위 밖에 존재하는 경우
        print("Point out of image bound")
        directCon = False #
        nodeCon = False
    else:
        # check direct connection
        if collision(x,y,end[0],end[1]): #collision인 경우
            directCon = False #경로의 방향성이 틀림.
        else: #collision이 아닌 경우
            directCon=True #경로의 방향성이 적절함.

        # check connection between two nodes
        if collision(x,y,x2,y2): #collision인 경우
            nodeCon = False #두 노드 사이 연결x
        else: #collsion이 아닌 경우
            nodeCon = True #두 노드 사이 연결0

    return(x,y,directCon,nodeCon)

# return dist and angle b/w new point and nearest node
def dist_and_angle(x1,y1,x2,y2):
    dist = math.sqrt( ((x1-x2)**2)+((y1-y2)**2) ) #거리 산출
    angle = math.atan2(y2-y1, x2-x1) #각도 산출
    return(dist,angle)

# return the neaerst node index
def nearest_node(x,y):
    temp_dist=[] #거리에 대한 임시 리스트
    for i in range(len(node_list)): #현재까지 저장된 노드에 대해서
        dist,_ = dist_and_angle(x,y,node_list[i].x,node_list[i].y) #저장되어 있는 각 노드들에 대한 거리 비교를 하며 nearest를 찾음. 이 부분은 나중에 모든 노드를 탐색하지 않는 제한 조건이 필요할 듯 함.
        temp_dist.append(dist) #각 노드 별 거리를 임시 리스트에 추가
    return temp_dist.index(min(temp_dist)) #임시 리스트에서 거리의 최소값을 갖는 거리의 인덱스를 반환

#랜덤 노드 좌표 생성
# generate a random point in the image space
def rnd_point(h,l): #이미지의 높이(h)와 폭(l)을 받아옴.
    new_y = random.randint(0, h) #0~h 사이의 랜덤 정수를 y좌표
    new_x = random.randint(0, l) #0~l 사이의 랜덤 정수를 x좌표
    return (new_x,new_y) 


def RRT(img, img2, start, end, stepSize):
    h,l= img.shape # h : 이미지 높이, l : 이미지 폭
    # print(img.shape) # (384, 683)
    # print(h,l)

    # insert the starting point in the node class
    # node_list = [0] # list to store all the node points         
    node_list[0] = Nodes(start[0],start[1]) #시작 노드의 좌표를 입력하여 노드 클래스를 node_list[0]에 초기화
    node_list[0].parent_x.append(start[0]) #시작 노드(node_list[0])의 부모노드 x좌표를 시작노드의 x좌표로 설정
    node_list[0].parent_y.append(start[1]) #시작 노드(node_list[1])의 부모노드 y좌표를 시작노드의 y좌표로 설정

    # 시작과 끝 노드를 img2에 표시
    cv2.circle(img2, (start[0],start[1]), 5,(0,0,255),thickness=3, lineType=8) 
    cv2.circle(img2, (end[0],end[1]), 5,(0,0,255),thickness=3, lineType=8)

    i=1
    pathFound = False #pathFound에 대한 flag설정
    while pathFound==False: #path를 찾지 못한 경우 동안 진행
        nx,ny = rnd_point(h,l) #랜덤 노드 좌표를 nx,ny에 초기화
        print("Random points:",nx,ny)

        nearest_ind = nearest_node(nx,ny) #(nx, ny)와 가장 가까운 트리 노드(node_list의 원소)를 nearest_node를 통해 탐색하여 가장 가까운 노드의 인덱스를 저장
        nearest_x = node_list[nearest_ind].x #nearest_x에 가장 가까운 노드의 x좌표 초기화
        nearest_y = node_list[nearest_ind].y #nearest_y에 가장 가까운 노드의 y좌표 초기화
        print("Nearest node coordinates:",nearest_x,nearest_y)

        #check direct connection
        tx,ty,directCon,nodeCon = check_collision(nx,ny,nearest_x,nearest_y) #가장 가까운 노드(nearest_x & nearest_y)에 step 사이즈를 더한 지점의 좌표(tx, ty)를 구하여 해당 좌표가 방향이 일치하는지(directCon), 노드가 연결가능한지(nodeCon) 판단
        print("Check collision:",tx,ty,directCon,nodeCon)

        if directCon and nodeCon: #방향이 end노드와 일치하고(end노드 직전의 노드라는 뜻) 노드를 연결할 수 있는 경우(충돌이 없는 경우)
            print("Node can connect directly with end")
            node_list.append(i) #node_list에 i를 저장. 초기 i는 1.
            node_list[i] = Nodes(tx,ty) #위에서 새로 추가된 자리에 Node(tx, ty)를 초기화. Node(tx, ty)는 랜덤 노드 역할.
            node_list[i].parent_x = node_list[nearest_ind].parent_x.copy() #새로 추가된 Node(tx, ty)의 부모노드 x좌표로 가장 가까운 트리 노드의  부모 노드 x좌표를 복사해서 초기화
            node_list[i].parent_y = node_list[nearest_ind].parent_y.copy() #새로 추가된 Node(tx, ty)의 부모노드 y좌표로 가장 가까운 트리 노드의  부모 노드 y좌표를 복사해서 초기화
            node_list[i].parent_x.append(tx) #Node(tx, ty)의 부모노드 x좌표를 tx로 설정
            node_list[i].parent_y.append(ty) #Node(tx, ty)의 부모노드 y좌표를 ty로 설정

            cv2.circle(img2, (int(tx),int(ty)), 2,(0,0,255),thickness=3, lineType=8) #Node(tx, ty) img2에 표현
            cv2.line(img2, (int(tx),int(ty)), (int(node_list[nearest_ind].x),int(node_list[nearest_ind].y)), (0,255,0), thickness=1, lineType=8) #부모노드와 연결을 표현
            cv2.line(img2, (int(tx),int(ty)), (end[0],end[1]), (255,0,0), thickness=2, lineType=8) #end노드와 연결을 표현

            print("Path has been found")
            #print("parent_x",node_list[i].parent_x)
            for j in range(len(node_list[i].parent_x)-1): #최근 node_list의 노드에 대해서 부모노드 리스트 접근. 인덱스이기 때문에 -1을 했지만 매트랩에서는 안해도 됨.
                cv2.line(img2, (int(node_list[i].parent_x[j]),int(node_list[i].parent_y[j])), (int(node_list[i].parent_x[j+1]),int(node_list[i].parent_y[j+1])), (255,0,0), thickness=2, lineType=8) #최근 node_list의 부모노드 리스트를 차례대로 연결
            # cv2.waitKey(1)
            cv2.imwrite("media/"+str(i)+".jpg",img2)
            cv2.imwrite("out.jpg",img2)
            break

        elif nodeCon: #노드연결만 가능하고 방향이 일치하지 않을 때 (start노드 이후로 end노드 직전 노드 사이의 노드들)
            print("Nodes connected")
            node_list.append(i) #node_list에 i 추가. 초기 i는 1
            node_list[i] = Nodes(tx,ty) #노드 클래스 Node(tx, ty)를 i번째 인덱스로 초기화
            node_list[i].parent_x = node_list[nearest_ind].parent_x.copy() #새로 추가된 Node(tx, ty)의 부모노드 x좌표로 가장 가까운 트리 노드의  부모 노드 x좌표를 복사해서 초기화
            node_list[i].parent_y = node_list[nearest_ind].parent_y.copy() #새로 추가된 Node(tx, ty)의 부모노드 y좌표로 가장 가까운 트리 노드의  부모 노드 y좌표를 복사해서 초기화
            # print(i)
            # print(node_list[nearest_ind].parent_y)
            node_list[i].parent_x.append(tx) #Node(tx, ty)의 부모노드 x좌표를 tx로 설정
            node_list[i].parent_y.append(ty)#Node(tx, ty)의 부모노드 y좌표를 ty로 설정
            i=i+1 #i+1
            # display
            cv2.circle(img2, (int(tx),int(ty)), 2,(0,0,255),thickness=3, lineType=8) #Node(tx, ty) 표현
            cv2.line(img2, (int(tx),int(ty)), (int(node_list[nearest_ind].x),int(node_list[nearest_ind].y)), (0,255,0), thickness=1, lineType=8) #가장 가까운 트리 노드와 연결
            cv2.imwrite("media/"+str(i)+".jpg",img2)
            cv2.imshow("sdc",img2)
            cv2.waitKey(1)
            continue

        else: (충돌로 인해 노드를 연결할 수 없는 경우)
            print("No direct con. and no node con. :( Generating new rnd numbers")
            continue

def draw_circle(event,x,y,flags,param):
    global coordinates
    if event == cv2.EVENT_LBUTTONDBLCLK:
        cv2.circle(img2,(x,y),5,(255,0,0),-1)
        coordinates.append(x)
        coordinates.append(y)



if __name__ == '__main__':

    parser = argparse.ArgumentParser(description = 'Below are the params:')
    parser.add_argument('-p', type=str, default='world2.png',metavar='ImagePath', action='store', dest='imagePath',
                    help='Path of the image containing mazes')
    parser.add_argument('-s', type=int, default=10,metavar='Stepsize', action='store', dest='stepSize',
                    help='Step-size to be used for RRT branches')
    parser.add_argument('-start', type=int, default=[20,20], metavar='startCoord', dest='start', nargs='+',
                    help='Starting position in the maze')
    parser.add_argument('-stop', type=int, default=[450,250], metavar='stopCoord', dest='stop', nargs='+',
                    help='End position in the maze')
    parser.add_argument('-selectPoint', help='Select start and end points from figure', action='store_true')

    args = parser.parse_args()

    # remove previously stored data
    try:
      os.system("rm -rf media")
    except:
      print("Dir already clean")
    os.mkdir("media")

    img = cv2.imread(args.imagePath,0) # load grayscale maze image
    img2 = cv2.imread(args.imagePath) # load colored maze image
    start = tuple(args.start) #(20,20) # starting coordinate #시작노드 좌표
    end = tuple(args.stop) #(450,250) # target coordinate #end노드 좌표
    stepSize = args.stepSize # stepsize for RRT #step 사이즈
    node_list = [0] # list to store all the node points #node_list 초기 상태

    coordinates=[]
    if args.selectPoint:
        print("Select start and end points by double clicking, press 'escape' to exit")
        cv2.namedWindow('image')
        cv2.setMouseCallback('image',draw_circle)
        while(1):
            cv2.imshow('image',img2)
            k = cv2.waitKey(20) & 0xFF
            if k == 27:
                break
        # print(coordinates)
        start=(coordinates[0],coordinates[1])
        end=(coordinates[2],coordinates[3])

    # run the RRT algorithm 
    RRT(img, img2, start, end, stepSize)